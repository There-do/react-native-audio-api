---
sidebar_position: 1
---

import { Optional, ReadOnly, IOS, Experimental } from '@site/src/components/Badges';

# AudioManager

The `AudioManager` is a layer of an abstraction between user and a system.
It provides a set of system-specific functions that are invoked directly in native code, by related system.

## Example

```tsx
import { AudioManager } from 'react-native-audio-api';
import { useEffect } from 'react';

function App() {
    // set AVAudioSession example options (iOS)
    AudioManager.setAudioSessionOptions({
      iosCategory: 'playback',
      iosMode: 'default',
      iosOptions: ['defaultToSpeaker', 'allowBluetoothA2DP'],
    })
    // enabling emission of events
    AudioManager.observeAudioInterruptions(true);
    AudioManager.getDevicesInfo().then(console.log);

  useEffect(() => {
    // callback to be invoked on 'interruption' event
    const interruptionSubscription = AudioManager.addSystemEventListener(
      'interruption',
      (event) => {
        console.log('Interruption event:', event);
      }
    );

    return () => {
      interruptionSubscription?.remove();
    };
  }, []);
}
```

## Methods

### `setAudioSessionOptions` <IOS />

| Parameter | Type | Description |
| :---: | :---: | :---- |
| options | [`SessionOptions`](/docs/system/audio-manager#sessionoptions) | Options to be set for [AVAudioSession](https://developer.apple.com/documentation/avfaudio/avaudiosession?language=objc#Configuring-standard-audio-behaviors) |

#### Returns `undefined`

### `setAudioSessionActivity` <IOS />

| Parameter | Type | Description |
| :---: | :---: | :---- |
| enabled | `boolean` | It is used to set/unset [AVAudioSession](https://developer.apple.com/documentation/avfaudio/avaudiosession?language=objc#Activating-the-audio-configuration) activity |

#### Returns promise of `boolean` type, which is resolved to `true` if invokation ended with success, `false` otherwise.'

### `disableSessionManagement` <IOS />

#### Returns `undefined`.

Disables all internal default [AVAudioSession](https://developer.apple.com/documentation/avfaudio/avaudiosession) configurations and management done by the `react-native-audio-api` package. After calling this method, user is responsible for managing audio session entirely on their own.
Typical use-case for this method is when user wants to fully control audio session outside of `react-native-audio-api` package,
commonly when using another audio library along `react-native-audio-api`. The method has to be called before `AudioContext` is created, for example in app initialization code.
Any later call to `setAudioSessionOptions` or `setAudioSessionActivity` will re-enable internal audio session management.

### `getDevicePreferredSampleRate`

#### Returns `number`.

### `observeAudioInterruptions`

| Parameter | Type | Description |
| :---: | :---: | :---- |
| `param` |  [`AudioFocusType`](audio-manager#audiofocustype) \| `boolean` \| `null` | It is used to enable/disable observing audio interruptions. Passing `false` or `null` disables the observation, otherwise it is enabled. |

:::info
On android passing the audio focus type set the native [audio focus](https://developer.android.com/media/optimize/audio-focus) accordingly.
It is recommended for apps to respect the rules for good user experience.
On iOS it just enables/disables event emission and has no additional effects.
:::

#### Returns `undefined`

### `activelyReclaimSession` <IOS /> <Experimental />

| Parameter | Type | Description |
| :---: | :---: | :---- |
| `enabled` | `boolean` | It is used to enable/disable session spoofing |

#### Returns `undefined`

More aggressively try to reactivate the audio session during interruptions.

In some cases (depends on app session settings and other apps using audio) system may never
send the `interruption ended` event. This method will check if any other audio is playing
and try to reactivate the audio session, as soon as there is "silence".
Although this might change the expected behavior.

Internally method uses `AVAudioSessionSilenceSecondaryAudioHintNotification` as well as
interval polling to check if other audio is playing.

### `observeVolumeChanges`

| Parameter | Type | Description |
| :---: | :---: | :---- |
| `enabled` | `boolean` | It is used to enable/disable observing volume changes |

#### Returns `undefined`


### `addSystemEventListener`

Adds callback to be invoked upon hearing an event.

| Parameter | Type | Description |
| :---: | :---: | :---- |
| `name` | [`SystemEventName`](audio-manager#systemeventname) | Name of an event listener |
| `callback` | [`SystemEventCallback`](audio-manager#systemeventname) | Callback that will be invoked upon hearing an event |

#### Returns [`AudioEventSubscription`](/docs/system/audio-manager#audioeventsubscription) if `enabled` is set to true, `undefined` otherwise

### `requestRecordingPermissions`

Brings up the system microphone permissions pop-up on demand. The pop-up automatically shows if microphone data
is directly requested, but sometimes it is better to ask beforehand.

#### Throws an `error` if there is no NSMicrophoneUsageDescription entry in `Info.plist`

#### Returns promise of [`PermissionStatus`](/docs/system/audio-manager#permissionstatus) type, which is resolved after receiving answer from the system.

### `checkRecordingPermissions`

Checks if permissions were previously granted.

#### Throws an `error` if there is no NSMicrophoneUsageDescription entry in `Info.plist`

#### Returns promise of [`PermissionStatus`](/docs/system/audio-manager#permissionstatus) type, which is resolved after receiving answer from the system.

### `requestNotificationPermissions`

Brings up the system notification permissions pop-up on demand. The pop-up automatically shows if notification data
is directly requested, but sometimes it is better to ask beforehand.

#### Returns promise of [`PermissionStatus`](/docs/system/audio-manager#permissionstatus) type, which is resolved after receiving answer from the system.

### `checkRecordingPermissions`

Checks if permissions were previously granted.

#### Returns promise of [`PermissionStatus`](/docs/system/audio-manager#permissionstatus) type, which is resolved after receiving answer from the system.

### `getDevicesInfo`

Checks currently used and available devices.

#### Returns promise of [`AudioDevicesInfo`](/docs/system/audio-manager#audiodevicesinfo) type, which is resolved after receiving answer from the system.

## Remarks

### `AudioFocusType`
<details>
<summary>Type definitions</summary>
```typescript
type AudioFocusType =
  | 'gain'
  | 'gainTransient'
  | 'gainTransientExclusive'
  | 'gainTransientMayDuck';
```
</details>

### `SessionOptions`

<details>
<summary>Type definitions</summary>
```typescript
type IOSCategory =
  | 'record'
  | 'ambient'
  | 'playback'
  | 'multiRoute'
  | 'soloAmbient'
  | 'playAndRecord';

type IOSMode =
  | 'default'
  | 'gameChat'
  | 'videoChat'
  | 'voiceChat'
  | 'measurement'
  | 'voicePrompt'
  | 'spokenAudio'
  | 'moviePlayback'
  | 'videoRecording';

type IOSOption =
  | 'duckOthers'
  | 'allowAirPlay'
  | 'mixWithOthers'
  | 'allowBluetoothHFP'
  | 'defaultToSpeaker'
  | 'allowBluetoothA2DP'
  | 'overrideMutedMicrophoneInterruption'
  | 'interruptSpokenAudioAndMixWithOthers';

interface SessionOptions {
  iosMode?: IOSMode;
  iosOptions?: IOSOption[];
  iosCategory?: IOSCategory;
  iosAllowHaptics?: boolean;
  // Has no effect when using PlaybackNotificationManager as it takes over the "Now playing" controls
  iosNotifyOthersOnDeactivation?: boolean;
}
```
</details>


### `SystemEventName`

<details>
<summary>Type definitions</summary>
```typescript
interface EventEmptyType {}

interface EventTypeWithValue {
  value: number;
}

interface OnInterruptionEventType {
  type: 'ended' | 'began'; // if the interruption event has started or ended
  shouldResume: boolean; // if the interruption was temporary and we can resume the playback/recording
}

interface OnRouteChangeEventType {
  reason:
    | 'Unknown'
    | 'Override'
    | 'CategoryChange'
    | 'WakeFromSleep'
    | 'NewDeviceAvailable'
    | 'OldDeviceUnavailable'
    | 'ConfigurationChange'
    | 'NoSuitableRouteForCategory';
}

type SystemEvents = {
  volumeChange: EventTypeWithValue;
  interruption: OnInterruptionEventType;
  duck: EventEmptyType;
  routeChange: OnRouteChangeEventType;
};

type SystemEventName = keyof SystemEvents;
type SystemEventCallback<Name extends SystemEventName> = (
  event: SystemEvents[Name]
) => void;
```
</details>


### `AudioEventSubscription`

<details>
<summary>Type definitions</summary>
```typescript
interface AudioEventSubscription {
  /** @internal */
  public readonly subscriptionId: string;

  public remove(): void; // used to remove the subscription
}
```
</details>

### `PermissionStatus`

<details>
<summary>Type definitions</summary>
```typescript
type PermissionStatus = 'Undetermined' | 'Denied' | 'Granted';
```
</details>

### `AudioDevicesInfo`

<details>
<summary>Type definitions</summary>
```typescript
export interface AudioDeviceInfo {
  name: string;
  category: string;
}

export type AudioDeviceList = AudioDeviceInfo[];

export interface AudioDevicesInfo {
  availableInputs: AudioDeviceList;
  availableOutputs: AudioDeviceList;
  currentInputs: AudioDeviceList; // iOS
  currentOutputs: AudioDeviceList; // iOS
}
```
</details>
